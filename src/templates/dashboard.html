{% extends 'base.html' %}
{% block title %}Dashboard{% endblock %}
{% block content %}
<div class="max-w-3xl mx-auto space-y-8">
  <h1 class="text-3xl font-semibold text-center">Dashboard</h1>
  <div class="space-y-1 text-sm">
    <p><strong>Email:</strong> {{ email }}</p>
    <p><strong>User ID:</strong> {{ user_id }}</p>
    <p><strong>Role:</strong> {{ role }}</p>
    {% if gpu_minutes_quota is not none %}
    <p><strong>GPU minutes quota:</strong> {{ gpu_minutes_quota }}</p>
    {% endif %}
  </div>
  <div class="p-4 rounded-lg border border-slate-700 bg-slate-900/60">
    <p class="text-xs font-semibold uppercase tracking-wide text-slate-400">Services</p>
    <p class="mt-2 text-sm">
      Ollama connection:
      {% if ollama_connected %}
      <span class="text-green-400 font-medium">Connected</span>
      {% else %}
      <span class="text-red-400 font-medium">Unavailable</span>
      {% endif %}
    </p>
    <p class="mt-1 text-xs text-slate-500 break-words">Endpoint: {{ ollama_url }}</p>
  </div>
  {% if session.get('role') == 'admin' %}
  <div class="text-right">
    <a href="/admin" class="px-4 py-2 rounded bg-indigo-500 hover:bg-indigo-400 text-slate-900 font-semibold">Admin Dashboard</a>
  </div>
  {% endif %}
  <form id="job-form" class="space-y-4">
    <input id="prompt" class="w-full px-4 py-2 rounded bg-slate-900 border border-slate-700 focus:outline-none focus:ring-2 focus:ring-teal-500" type="text" placeholder="Enter prompt" required />
    <input id="image-url" class="w-full px-4 py-2 rounded bg-slate-900 border border-slate-700 focus:outline-none focus:ring-2 focus:ring-teal-500" type="text" placeholder="Image URL" required />
    <button class="w-full py-2 rounded bg-teal-500 hover:bg-teal-400 text-slate-900 font-semibold" type="submit">Submit</button>
  </form>
  <section class="p-4 rounded-lg border border-slate-700 bg-slate-900/40 space-y-2">
    <h2 class="text-sm font-semibold text-slate-200">Wikipedia scraping debug</h2>
    <div id="scrape-status" class="text-xs text-slate-400 space-y-1"></div>
    <div id="scrape-debug" class="text-sm text-slate-300">
      Submit a prompt to trigger the Wikipedia scraping pipeline and the summary will be displayed here.
    </div>
  </section>
  <div class="text-right">
    <button id="refresh-jobs" class="px-4 py-2 rounded bg-teal-500 hover:bg-teal-400 text-slate-900 font-semibold">Refresh Jobs</button>
  </div>
  <table class="min-w-full text-sm" id="jobs-table">
    <thead>
      <tr class="text-left">
        <th class="px-2 py-1">ID</th>
        <th class="px-2 py-1">Prompt</th>
        <th class="px-2 py-1">Provider</th>
        <th class="px-2 py-1">Request ID</th>
        <th class="px-2 py-1">Status</th>
        <th class="px-2 py-1">Submitted</th>
        <th class="px-2 py-1">Video</th>
      </tr>
    </thead>
    <tbody id="jobs-body"></tbody>
  </table>
</div>
<script>

const USER_ID = {{ user_id | tojson }};
const debugOutput = document.getElementById('scrape-debug');
const statusOutput = document.getElementById('scrape-status');
const STATUS_STEPS = [
  { id: 'queued', label: 'Job queued' },
  { id: 'summary', label: 'Ollama summary' },
  { id: 'fal_request', label: 'fal.ai submission' },
  { id: 'webhook', label: 'Webhook update' },
  { id: 'generation', label: 'Video generation' }
];
const statusElements = new Map();
let pollSequence = 0;

function updateDebugMessage(message, tone = 'info') {
  if (!debugOutput) return;
  debugOutput.innerHTML = '';
  const p = document.createElement('p');
  p.textContent = message;
  if (tone === 'error') {
    p.className = 'text-red-400';
  } else if (tone === 'success') {
    p.className = 'text-green-400';
  } else {
    p.className = 'text-slate-300';
  }
  debugOutput.appendChild(p);
}

function initStatusUI() {
  if (!statusOutput) return;
  statusElements.clear();
  statusOutput.innerHTML = '';
  STATUS_STEPS.forEach(({ id, label }) => {
    const row = document.createElement('div');
    row.className = 'flex items-center gap-2';
    const badge = document.createElement('span');
    badge.className = 'inline-flex w-2.5 h-2.5 rounded-full bg-slate-700';
    const textEl = document.createElement('span');
    textEl.className = 'text-xs text-slate-400';
    textEl.textContent = `${label}: Pending`;
    row.appendChild(badge);
    row.appendChild(textEl);
    statusOutput.appendChild(row);
    statusElements.set(id, { badge, text: textEl, label });
  });
}

function setStatus(stepId, state = 'pending', customMessage) {
  if (!statusOutput) return;
  if (!statusElements.size) {
    initStatusUI();
  }
  const entry = statusElements.get(stepId);
  if (!entry) return;
  const { badge, text, label } = entry;
  let badgeColor = 'bg-slate-700';
  let textColor = 'text-slate-400';
  let message = customMessage;
  switch (state) {
    case 'active':
      badgeColor = 'bg-amber-400';
      textColor = 'text-amber-200';
      message = message || 'In progress';
      break;
    case 'done':
      badgeColor = 'bg-emerald-500';
      textColor = 'text-emerald-300';
      message = message || 'Completed';
      break;
    case 'error':
      badgeColor = 'bg-red-500';
      textColor = 'text-red-300';
      message = message || 'Error';
      break;
    default:
      badgeColor = 'bg-slate-700';
      textColor = 'text-slate-400';
      message = message || 'Pending';
  }
  badge.className = `inline-flex w-2.5 h-2.5 rounded-full ${badgeColor}`;
  text.className = `text-xs ${textColor}`;
  text.textContent = `${label}: ${message}`;
}

function resetStatuses() {
  if (!statusOutput) return;
  initStatusUI();
}

function updateGenerationStatus(message, tone = 'info') {
  if (!debugOutput) return;
  let note = document.getElementById('generation-status');
  if (!note) {
    note = document.createElement('p');
    note.id = 'generation-status';
    note.className = 'text-xs text-slate-400 mt-3';
    debugOutput.appendChild(note);
  }
  let className = 'text-xs text-slate-400 mt-3';
  if (tone === 'error') {
    className = 'text-xs text-red-300 mt-3';
  } else if (tone === 'success') {
    className = 'text-xs text-emerald-300 mt-3';
  } else if (tone === 'active') {
    className = 'text-xs text-amber-200 mt-3';
  }
  note.className = className;
  note.textContent = message;
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function renderScrapeResults(data, jobId) {
  if (!debugOutput) return;
  debugOutput.innerHTML = '';

  const heading = document.createElement('p');
  heading.className = 'text-xs uppercase tracking-wide text-slate-400';
  heading.textContent = jobId ? `Job #${jobId} scraping results` : 'Scraping results';
  debugOutput.appendChild(heading);

  const keywordsLine = document.createElement('p');
  keywordsLine.className = 'text-slate-300 mt-2';
  const keywords = Array.isArray(data.keywords) && data.keywords.length ? data.keywords.join(', ') : 'N/A';
  keywordsLine.textContent = `Keywords: ${keywords}`;
  debugOutput.appendChild(keywordsLine);

  const summary = document.createElement('p');
  summary.className = 'text-slate-200 mt-2';
  summary.textContent = data.summary ? data.summary : 'No summary generated.';
  debugOutput.appendChild(summary);

  if (data.results && typeof data.results === 'object') {
    const list = document.createElement('ul');
    list.className = 'list-disc list-inside mt-2 space-y-1 text-slate-400';
    Object.entries(data.results).forEach(([keyword, links]) => {
      const li = document.createElement('li');
      if (Array.isArray(links) && links.length) {
        const displayLinks = links.slice(0, 3).join(', ');
        li.textContent = `${keyword}: ${displayLinks}`;
      } else {
        li.textContent = `${keyword}: No links found`;
      }
      list.appendChild(li);
    });
    debugOutput.appendChild(list);
  }

  if (Array.isArray(data.errors) && data.errors.length) {
    const errorHeading = document.createElement('p');
    errorHeading.className = 'text-red-400 font-semibold mt-3';
    errorHeading.textContent = 'Errors';
    debugOutput.appendChild(errorHeading);

    const errorsList = document.createElement('ul');
    errorsList.className = 'list-disc list-inside mt-1 space-y-1 text-red-300';
    data.errors.forEach(message => {
      const li = document.createElement('li');
      li.textContent = message;
      errorsList.appendChild(li);
    });
    debugOutput.appendChild(errorsList);
  }
}

function normalizeError(err) {
  if (err instanceof Error) return err.message;
  return typeof err === 'string' ? err : JSON.stringify(err);
}

async function loadJobs() {
  const res = await fetch(`/list_jobs/${USER_ID}`, { cache: 'no-store' });
  const jobs = await res.json();
  const body = document.getElementById('jobs-body');
  body.innerHTML = '';
  jobs.forEach(job => {
    const tr = document.createElement('tr');
    let videoLinks = '';
    if (job.video_url) {
      videoLinks = `<a href="${job.video_url}" target="_blank" class="text-teal-400">View</a>`+
                   ` <a href="${job.video_url}" download class="text-teal-400 ml-2">Download</a>`;
    }
    const provider = job.provider || '—';
    const requestId = job.external_job_id || '—';
    const promptText = job.prompt || '';
    const submittedAt = job.submitted_at || '—';
    const statusText = job.status || '—';
    tr.innerHTML = `<td class="px-2 py-1">${job.id}</td>`+
                   `<td class="px-2 py-1">${promptText}</td>`+
                   `<td class="px-2 py-1">${provider}</td>`+
                   `<td class="px-2 py-1">${requestId}</td>`+
                   `<td class="px-2 py-1">${statusText}</td>`+
                   `<td class="px-2 py-1">${submittedAt}</td>`+
                   `<td class="px-2 py-1">${videoLinks}</td>`;
    body.appendChild(tr);
  });
}

async function pollJobUntilComplete(jobId, options = {}) {
  const { interval = 5000, maxAttempts = 15, requestId = null } = options;
  const sequence = ++pollSequence;
  let lastStatus = null;
  let knownRequestId = requestId;

  for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
    if (sequence !== pollSequence) {
      return;
    }
    if (attempt > 0) {
      await sleep(interval);
    }
    if (sequence !== pollSequence) {
      return;
    }

    let res;
    try {
      res = await fetch(`/list_jobs/${USER_ID}`, {
        cache: 'no-store',
        headers: { Accept: 'application/json' }
      });
    } catch (err) {
      console.error('Failed to poll job status', err);
      continue;
    }

    if (!res.ok) {
      console.warn('Job status request failed', res.status, res.statusText);
      continue;
    }

    let jobs;
    try {
      jobs = await res.json();
    } catch (err) {
      console.error('Failed to parse jobs payload', err);
      continue;
    }

    if (!Array.isArray(jobs)) {
      console.warn('Unexpected jobs payload', jobs);
      continue;
    }

    const job = jobs.find(j => j.id === jobId);
    if (!job) {
      setStatus('webhook', 'active', 'Waiting for Supabase record');
      updateGenerationStatus(`Waiting for job #${jobId} to appear in Supabase…`, 'active');
      continue;
    }

    if (job.status !== lastStatus) {
      lastStatus = job.status;
      loadJobs();
    }

    if (job.external_job_id && job.external_job_id !== knownRequestId) {
      knownRequestId = job.external_job_id;
      setStatus('fal_request', 'done', `Request ${knownRequestId} accepted`);
    }

    const normalizedStatus = typeof job.status === 'string' ? job.status.toLowerCase() : '';

    if (normalizedStatus === 'succeeded') {
      if (sequence !== pollSequence) return;
      setStatus('webhook', 'done', 'fal.ai delivered the result');
      setStatus('generation', 'done', 'Video ready');
      const reqDisplay = knownRequestId ? ` (request ${knownRequestId})` : '';
      updateGenerationStatus(`Video generated successfully for job #${jobId}${reqDisplay}.`, 'success');
      loadJobs();
      return;
    }

    if (normalizedStatus === 'failed') {
      if (sequence !== pollSequence) return;
      setStatus('webhook', 'error', 'fal.ai reported a failure');
      setStatus('generation', 'error', 'Generation failed');
      const reqDisplay = knownRequestId ? ` (request ${knownRequestId})` : '';
      updateGenerationStatus(`Video generation failed for job #${jobId}${reqDisplay}.`, 'error');
      loadJobs();
      return;
    }

    if (normalizedStatus === 'running') {
      setStatus('webhook', 'active', 'fal.ai processing');
      setStatus('generation', 'active', 'Video generation in progress');
      const reqDisplay = knownRequestId ? ` (request ${knownRequestId})` : '';
      updateGenerationStatus(`Video generation in progress${reqDisplay}…`, 'active');
    } else if (normalizedStatus === 'queued') {
      setStatus('webhook', 'active', 'Waiting for fal.ai to start');
      setStatus('generation', 'pending', 'Waiting to start');
      const reqDisplay = knownRequestId ? ` (request ${knownRequestId})` : '';
      updateGenerationStatus(`Job queued for generation${reqDisplay}…`, 'active');
    } else {
      setStatus('webhook', 'active', job.status || 'In progress');
      setStatus('generation', 'active', 'Processing update received');
      updateGenerationStatus(`Current job status: ${job.status}`, 'active');
    }
  }

  if (sequence !== pollSequence) {
    return;
  }
  setStatus('webhook', 'error', 'Timed out waiting for webhook');
  setStatus('generation', 'error', 'Timed out');
  updateGenerationStatus('Timed out waiting for video generation to finish.', 'error');
}

document.getElementById('job-form').addEventListener('submit', async (e) => {
  e.preventDefault();
  const prompt = document.getElementById('prompt').value;
  const imageUrl = document.getElementById('image-url').value;
  resetStatuses();
  setStatus('queued', 'active', 'Submitting job');
  setStatus('fal_request', 'active', 'Sending request to fal.ai');
  setStatus('webhook', 'pending', 'Waiting for webhook');
  updateDebugMessage('Submitting job to fal.ai...');
  let jobData;
  let jobId = null;
  let externalJobId = null;
  let webhookUrl = null;
  try {
    const jobRes = await fetch('/submit_job_fal', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        user_id: USER_ID,
        prompt,
        text_input: prompt,
        image_url: imageUrl
      })
    });

    let payload;
    try {
      payload = await jobRes.json();
    } catch (_) {
      setStatus('queued', 'error', 'Invalid server response');
      setStatus('fal_request', 'error', 'fal.ai submission failed');
      setStatus('webhook', 'error', 'Webhook not scheduled');
      throw new Error('Failed to parse response from server');
    }

    if (jobRes.ok) {
      jobData = payload;
      jobId = jobData.job_id ?? jobData.id ?? null;
      externalJobId = jobData.external_job_id || jobData.request_id || null;
      webhookUrl = jobData.webhook_url || null;
      setStatus('queued', 'done', jobId ? `Job #${jobId} queued` : 'Job queued');
      const requestMessage = externalJobId ? `Request ${externalJobId} queued` : 'Request queued';
      setStatus('fal_request', 'done', requestMessage);
      setStatus('webhook', 'active', 'Awaiting fal.ai webhook');
      const details = [
        jobId ? `Job #${jobId} queued on fal.ai.` : 'Job queued on fal.ai.',
        externalJobId ? `Request ID: ${externalJobId}` : null,
        webhookUrl ? `Webhook: ${webhookUrl}` : null
      ].filter(Boolean).join(' ');
      updateDebugMessage(details || 'Job queued.', 'success');
    } else {
      let detail = `${jobRes.status} ${jobRes.statusText}`;
      if (payload && payload.error) {
        detail = payload.error;
      }
      setStatus('queued', 'error', 'Job submission failed');
      setStatus('fal_request', 'error', 'fal.ai submission failed');
      setStatus('webhook', 'error', 'Webhook not scheduled');
      throw new Error(detail);
    }

    if (e.target && typeof e.target.reset === 'function') {
      e.target.reset();
    }

    loadJobs();
  } catch (err) {
    setStatus('queued', 'error', 'Job submission failed');
    setStatus('fal_request', 'error', 'fal.ai submission failed');
    setStatus('webhook', 'error', 'Webhook not scheduled');
    updateDebugMessage(`Job submission failed: ${normalizeError(err)}`, 'error');
    return;
  }

  const summaryJobId = jobId ?? jobData?.id;
  setStatus('summary', 'active', 'Fetching Wikipedia data with Ollama');
  const submissionNote = summaryJobId ? `Job #${summaryJobId}` : 'Job';
  const requestNote = externalJobId ? ` (request ${externalJobId})` : '';
  updateDebugMessage(`${submissionNote}${requestNote} submitted. Running Wikipedia scraping debug...`);

  try {
    const summaryRes = await fetch('/wiki_summary', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ query: prompt })
    });

    if (!summaryRes.ok) {
      let detail = `${summaryRes.status} ${summaryRes.statusText}`;
      try {
        const payload = await summaryRes.json();
        if (payload && payload.error) {
          detail = payload.error;
        }
      } catch (_) {}
      setStatus('summary', 'error', 'Summary failed');
      setStatus('generation', 'pending', 'Waiting to start');
      throw new Error(detail);
    }

    const data = await summaryRes.json();
    setStatus('summary', 'done', 'Course script generated');
    renderScrapeResults(data, summaryJobId);
  } catch (err) {
    updateDebugMessage(`Scraping debug failed: ${normalizeError(err)}`, 'error');
    return;
  }

  setStatus('generation', 'active', 'Waiting for generation update');
  setStatus('webhook', 'active', 'Waiting for fal.ai webhook');
  updateGenerationStatus('Awaiting video generation status...', 'active');
  const pollJobId = summaryJobId ?? jobData.id;
  if (pollJobId == null) {
    setStatus('generation', 'error', 'Missing job identifier');
    setStatus('webhook', 'error', 'Missing job identifier');
    updateGenerationStatus('Cannot monitor job without an ID.', 'error');
    return;
  }
  pollJobUntilComplete(pollJobId, { requestId: externalJobId }).catch((err) => {
    setStatus('generation', 'error', 'Status check failed');
    setStatus('webhook', 'error', 'Status check failed');
    updateGenerationStatus(`Failed to check job status: ${normalizeError(err)}`, 'error');
  });
});

const refreshButton = document.getElementById('refresh-jobs');
if (refreshButton) {
  refreshButton.addEventListener('click', loadJobs);
}

document.addEventListener('DOMContentLoaded', () => {
  initStatusUI();
  loadJobs();
});

</script>
{% endblock %}
