{% extends 'base.html' %}
{% block title %}Dashboard{% endblock %}
{% block content %}
<div class="max-w-3xl mx-auto space-y-8">
  <h1 class="text-3xl font-semibold text-center">Dashboard</h1>
  <div class="space-y-1 text-sm">
    <p><strong>Email:</strong> {{ email }}</p>
    <p><strong>User ID:</strong> {{ user_id }}</p>
    <p><strong>Role:</strong> {{ role }}</p>
    {% if gpu_minutes_quota is not none %}
    <p><strong>GPU minutes quota:</strong> {{ gpu_minutes_quota }}</p>
    {% endif %}
  </div>
  <div class="p-4 rounded-lg border border-slate-700 bg-slate-900/60">
    <p class="text-xs font-semibold uppercase tracking-wide text-slate-400">Services</p>
    <p class="mt-2 text-sm">
      Ollama connection:
      {% if ollama_connected %}
      <span class="text-green-400 font-medium">Connected</span>
      {% else %}
      <span class="text-red-400 font-medium">Unavailable</span>
      {% endif %}
    </p>
    <p class="mt-1 text-xs text-slate-500 break-words">Endpoint: {{ ollama_url }}</p>
  </div>
  {% if session.get('role') == 'admin' %}
  <div class="text-right">
    <a href="/admin" class="px-4 py-2 rounded bg-indigo-500 hover:bg-indigo-400 text-slate-900 font-semibold">Admin Dashboard</a>
  </div>
  {% endif %}
  <form id="job-form" class="space-y-4">
    <input id="prompt" class="w-full px-4 py-2 rounded bg-slate-900 border border-slate-700 focus:outline-none focus:ring-2 focus:ring-teal-500" type="text" placeholder="Enter prompt" required />
    <input id="image-url" class="w-full px-4 py-2 rounded bg-slate-900 border border-slate-700 focus:outline-none focus:ring-2 focus:ring-teal-500" type="text" placeholder="Image URL" required />
    <button class="w-full py-2 rounded bg-teal-500 hover:bg-teal-400 text-slate-900 font-semibold" type="submit">Submit</button>
  </form>
  <section class="p-4 rounded-lg border border-slate-700 bg-slate-900/40 space-y-2">
    <h2 class="text-sm font-semibold text-slate-200">Wikipedia scraping debug</h2>
    <div id="scrape-status" class="text-xs text-slate-400 space-y-1"></div>
    <div id="scrape-debug" class="text-sm text-slate-300">
      Submit a prompt to trigger the Wikipedia scraping pipeline and the summary will be displayed here.
    </div>
    <div class="mt-4 rounded-lg border border-slate-800 bg-slate-900/60 p-3">
      <p class="text-xs font-semibold uppercase tracking-wide text-slate-400">Latest fal.ai webhook</p>
      <p id="webhook-note" class="text-xs text-slate-400 mt-2">No webhook updates yet.</p>
      <pre id="webhook-payload" class="mt-2 max-h-64 overflow-auto rounded bg-slate-950/80 p-3 text-xs text-slate-300">—</pre>
    </div>
  </section>
  <div class="text-right">
    <button id="refresh-jobs" class="px-4 py-2 rounded bg-teal-500 hover:bg-teal-400 text-slate-900 font-semibold">Refresh Jobs</button>
  </div>
  <table class="min-w-full text-sm" id="jobs-table">
    <thead>
      <tr class="text-left">
        <th class="px-2 py-1">ID</th>
        <th class="px-2 py-1">Prompt</th>
        <th class="px-2 py-1">Provider</th>
        <th class="px-2 py-1">Request ID</th>
        <th class="px-2 py-1">Status</th>
        <th class="px-2 py-1">Error</th>
        <th class="px-2 py-1">Submitted</th>
        <th class="px-2 py-1">Video</th>
      </tr>
    </thead>
    <tbody id="jobs-body"></tbody>
  </table>
  <section class="mt-8 space-y-3">
    <div class="flex items-center justify-between">
      <h2 class="text-lg font-semibold text-slate-200">Generated videos</h2>
      <button id="refresh-videos" class="px-4 py-2 rounded bg-indigo-500 hover:bg-indigo-400 text-slate-900 font-semibold">Refresh Videos</button>
    </div>
    <table class="min-w-full text-sm" id="videos-table">
      <thead>
        <tr class="text-left">
          <th class="px-2 py-1">ID</th>
          <th class="px-2 py-1">Title</th>
          <th class="px-2 py-1">Source</th>
          <th class="px-2 py-1">Job</th>
          <th class="px-2 py-1">Created</th>
        </tr>
      </thead>
      <tbody id="videos-body">
        <tr>
          <td class="px-2 py-2 text-slate-400" colspan="5">No videos loaded yet.</td>
        </tr>
      </tbody>
    </table>
  </section>
</div>
<script>

const USER_ID = {{ user_id | tojson }};
const debugOutput = document.getElementById('scrape-debug');
const statusOutput = document.getElementById('scrape-status');
const webhookNote = document.getElementById('webhook-note');
const webhookPayloadEl = document.getElementById('webhook-payload');
const videosBody = document.getElementById('videos-body');
const STATUS_STEPS = [
  { id: 'queued', label: 'Job queued' },
  { id: 'summary', label: 'Ollama summary' },
  { id: 'fal_request', label: 'fal.ai submission' },
  { id: 'webhook', label: 'Webhook update' },
  { id: 'generation', label: 'Video generation' }
];
const statusElements = new Map();
let pollSequence = 0;
let activeJobId = null;

function clearWebhookDisplay(message = 'No webhook updates yet.') {
  if (webhookNote) {
    webhookNote.textContent = message;
    webhookNote.className = 'text-xs text-slate-400 mt-2';
  }
  if (webhookPayloadEl) {
    webhookPayloadEl.textContent = '—';
  }
}

function stringifyForDisplay(value) {
  if (value === null || value === undefined) {
    return '';
  }
  if (typeof value === 'string') {
    return value;
  }
  try {
    return JSON.stringify(value, null, 2);
  } catch (_) {
    return String(value);
  }
}

function extractWebhookDebug(job) {
  if (!job || typeof job !== 'object') {
    return null;
  }
  let params = job.params;
  if (!params || typeof params !== 'object') {
    params = safeJsonParse(params);
  }
  if (!params || typeof params !== 'object') {
    return null;
  }
  let debugInfo = params.debug || params.Debug || params.fal_debug || params.falDebug;
  if (typeof debugInfo === 'string') {
    debugInfo = safeJsonParse(debugInfo);
  }
  if (!debugInfo || typeof debugInfo !== 'object') {
    return null;
  }
  return debugInfo;
}

function normalizeWebhookEvent(event) {
  if (!event) return null;
  if (typeof event === 'string') {
    const parsed = safeJsonParse(event);
    if (parsed && typeof parsed === 'object') {
      return parsed;
    }
    return { raw: event };
  }
  if (typeof event === 'object') {
    return event;
  }
  return null;
}

function extractLatestWebhookEvent(job) {
  const debugInfo = extractWebhookDebug(job);
  if (!debugInfo) {
    return null;
  }
  let event = debugInfo.last_webhook_event || debugInfo.lastWebhookEvent;
  if (!event) {
    const history = Array.isArray(debugInfo.webhook_events)
      ? debugInfo.webhook_events
      : Array.isArray(debugInfo.webhookEvents)
        ? debugInfo.webhookEvents
        : null;
    if (history && history.length) {
      event = history[history.length - 1];
    }
  }
  return normalizeWebhookEvent(event);
}

function renderWebhookEvent(job) {
  if (!webhookNote || !webhookPayloadEl) {
    return;
  }
  if (!job) {
    clearWebhookDisplay('No job selected.');
    return;
  }
  const event = extractLatestWebhookEvent(job);
  if (!event) {
    const label = job.id != null ? `job #${job.id}` : 'this job';
    clearWebhookDisplay(`No webhook updates recorded for ${label} yet.`);
    return;
  }

  const statusValue = typeof event.status === 'string' ? event.status : '';
  const statusLower = statusValue.toLowerCase();
  let noteClass = 'text-xs text-slate-300 mt-2';
  if (statusLower.includes('fail') || statusLower.includes('error') || statusLower.includes('cancel')) {
    noteClass = 'text-xs text-red-300 mt-2';
  } else if (statusLower.includes('success') || statusLower.includes('ok') || statusLower.includes('complete')) {
    noteClass = 'text-xs text-emerald-300 mt-2';
  } else if (statusLower.includes('progress') || statusLower.includes('queue')) {
    noteClass = 'text-xs text-amber-200 mt-2';
  }
  webhookNote.className = noteClass;

  const details = [];
  if (statusValue) {
    details.push(`Status: ${statusValue}`);
  }
  const receivedAt = event.received_at || event.receivedAt;
  if (receivedAt) {
    details.push(`Received at ${receivedAt}`);
  }
  const reqId = event.request_id || event.requestId || job.external_job_id || job.externalJobId;
  if (reqId) {
    details.push(`Request ${reqId}`);
  }
  const gatewayId = event.gateway_request_id || event.gatewayRequestId;
  if (gatewayId) {
    details.push(`Gateway ${gatewayId}`);
  }
  webhookNote.textContent = details.length ? details.join(' • ') : 'Webhook update received.';

  const payloadForDisplay =
    event.content ?? event.raw_payload ?? event.payload ?? event;
  webhookPayloadEl.textContent = stringifyForDisplay(payloadForDisplay);
}

clearWebhookDisplay();

function updateDebugMessage(message, tone = 'info') {
  if (!debugOutput) return;
  debugOutput.innerHTML = '';
  const p = document.createElement('p');
  p.textContent = message;
  if (tone === 'error') {
    p.className = 'text-red-400';
  } else if (tone === 'success') {
    p.className = 'text-green-400';
  } else {
    p.className = 'text-slate-300';
  }
  debugOutput.appendChild(p);
}

function initStatusUI() {
  if (!statusOutput) return;
  statusElements.clear();
  statusOutput.innerHTML = '';
  STATUS_STEPS.forEach(({ id, label }) => {
    const row = document.createElement('div');
    row.className = 'flex items-center gap-2';
    const badge = document.createElement('span');
    badge.className = 'inline-flex w-2.5 h-2.5 rounded-full bg-slate-700';
    const textEl = document.createElement('span');
    textEl.className = 'text-xs text-slate-400';
    textEl.textContent = `${label}: Pending`;
    row.appendChild(badge);
    row.appendChild(textEl);
    statusOutput.appendChild(row);
    statusElements.set(id, { badge, text: textEl, label });
  });
}

function setStatus(stepId, state = 'pending', customMessage) {
  if (!statusOutput) return;
  if (!statusElements.size) {
    initStatusUI();
  }
  const entry = statusElements.get(stepId);
  if (!entry) return;
  const { badge, text, label } = entry;
  let badgeColor = 'bg-slate-700';
  let textColor = 'text-slate-400';
  let message = customMessage;
  switch (state) {
    case 'active':
      badgeColor = 'bg-amber-400';
      textColor = 'text-amber-200';
      message = message || 'In progress';
      break;
    case 'done':
      badgeColor = 'bg-emerald-500';
      textColor = 'text-emerald-300';
      message = message || 'Completed';
      break;
    case 'error':
      badgeColor = 'bg-red-500';
      textColor = 'text-red-300';
      message = message || 'Error';
      break;
    default:
      badgeColor = 'bg-slate-700';
      textColor = 'text-slate-400';
      message = message || 'Pending';
  }
  badge.className = `inline-flex w-2.5 h-2.5 rounded-full ${badgeColor}`;
  text.className = `text-xs ${textColor}`;
  text.textContent = `${label}: ${message}`;
}

function resetStatuses() {
  if (!statusOutput) return;
  initStatusUI();
}

function updateGenerationStatus(message, tone = 'info') {
  if (!debugOutput) return;
  showGenerationVideoLinks(null);
  let note = document.getElementById('generation-status');
  if (!note) {
    note = document.createElement('p');
    note.id = 'generation-status';
    note.className = 'text-xs text-slate-400 mt-3';
    debugOutput.appendChild(note);
  }
  let className = 'text-xs text-slate-400 mt-3';
  if (tone === 'error') {
    className = 'text-xs text-red-300 mt-3';
  } else if (tone === 'success') {
    className = 'text-xs text-emerald-300 mt-3';
  } else if (tone === 'active') {
    className = 'text-xs text-amber-200 mt-3';
  }
  note.className = className;
  note.textContent = message;
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function renderScrapeResults(data, jobId) {
  if (!debugOutput) return;
  debugOutput.innerHTML = '';

  const heading = document.createElement('p');
  heading.className = 'text-xs uppercase tracking-wide text-slate-400';
  heading.textContent = jobId ? `Job #${jobId} scraping results` : 'Scraping results';
  debugOutput.appendChild(heading);

  const keywordsLine = document.createElement('p');
  keywordsLine.className = 'text-slate-300 mt-2';
  const keywords = Array.isArray(data.keywords) && data.keywords.length ? data.keywords.join(', ') : 'N/A';
  keywordsLine.textContent = `Keywords: ${keywords}`;
  debugOutput.appendChild(keywordsLine);

  const summary = document.createElement('p');
  summary.className = 'text-slate-200 mt-2';
  summary.textContent = data.summary ? data.summary : 'No summary generated.';
  debugOutput.appendChild(summary);

  if (data.results && typeof data.results === 'object') {
    const list = document.createElement('ul');
    list.className = 'list-disc list-inside mt-2 space-y-1 text-slate-400';
    Object.entries(data.results).forEach(([keyword, links]) => {
      const li = document.createElement('li');
      if (Array.isArray(links) && links.length) {
        const displayLinks = links.slice(0, 3).join(', ');
        li.textContent = `${keyword}: ${displayLinks}`;
      } else {
        li.textContent = `${keyword}: No links found`;
      }
      list.appendChild(li);
    });
    debugOutput.appendChild(list);
  }

  if (Array.isArray(data.errors) && data.errors.length) {
    const errorHeading = document.createElement('p');
    errorHeading.className = 'text-red-400 font-semibold mt-3';
    errorHeading.textContent = 'Errors';
    debugOutput.appendChild(errorHeading);

    const errorsList = document.createElement('ul');
    errorsList.className = 'list-disc list-inside mt-1 space-y-1 text-red-300';
    data.errors.forEach(message => {
      const li = document.createElement('li');
      li.textContent = message;
      errorsList.appendChild(li);
    });
    debugOutput.appendChild(errorsList);
  }
}

function normalizeError(err) {
  if (err instanceof Error) return err.message;
  if (err === null || err === undefined) return '';
  if (typeof err === 'string') return err;
  try {
    return JSON.stringify(err);
  } catch (serializationError) {
    return String(err);
  }
}

function formatJobErrorDetail(err) {
  const normalized = normalizeError(err).trim();
  if (!normalized || normalized === 'null' || normalized === 'undefined') {
    return { short: '', full: '' };
  }
  const limit = 160;
  const short = normalized.length > limit ? `${normalized.slice(0, limit - 1)}…` : normalized;
  return { short, full: normalized };
}

function escapeHtml(value) {
  if (value === null || value === undefined) return '';
  return String(value)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
    .replace(/\n/g, '&#10;')
    .replace(/\r/g, '&#13;');
}

function safeJsonParse(value) {
  if (typeof value !== 'string') {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_) {
    return null;
  }
}

function extractVideoUrlFromPayload(payload) {
  if (!payload) return null;
  if (typeof payload === 'string') {
    return payload.trim() || null;
  }
  if (Array.isArray(payload)) {
    for (const item of payload) {
      const nested = extractVideoUrlFromPayload(item);
      if (nested) return nested;
    }
    return null;
  }
  if (typeof payload === 'object') {
    const directKeys = ['video_url', 'videoUrl', 'url', 'signed_url', 'source_url'];
    for (const key of directKeys) {
      const value = payload[key];
      if (typeof value === 'string' && value) {
        return value;
      }
    }
    if (payload.video) {
      const nestedVideo = extractVideoUrlFromPayload(payload.video);
      if (nestedVideo) return nestedVideo;
    }
    if (Array.isArray(payload.videos)) {
      for (const item of payload.videos) {
        const nested = extractVideoUrlFromPayload(item);
        if (nested) return nested;
      }
    }
    const nestedKeys = ['payload', 'data', 'response', 'result'];
    for (const key of nestedKeys) {
      if (payload[key]) {
        const nested = extractVideoUrlFromPayload(payload[key]);
        if (nested) return nested;
      }
    }
  }
  return null;
}

function extractVideoUrlFromJob(job) {
  if (!job || typeof job !== 'object') return null;
  if (typeof job.video_url === 'string' && job.video_url) {
    return job.video_url;
  }
  if (typeof job.videoUrl === 'string' && job.videoUrl) {
    return job.videoUrl;
  }
  const params = job.params;
  let parsedParams = params;
  if (!parsedParams || typeof parsedParams !== 'object') {
    parsedParams = safeJsonParse(params);
  }
  if (parsedParams && typeof parsedParams === 'object') {
    const falResult = parsedParams.fal_result || parsedParams.falResult || parsedParams.result;
    const url = extractVideoUrlFromPayload(falResult);
    if (url) return url;
  }
  if (job.fal_result) {
    const url = extractVideoUrlFromPayload(job.fal_result);
    if (url) return url;
  }
  return extractVideoUrlFromPayload(job);
}

function showGenerationVideoLinks(videoUrl) {
  const note = document.getElementById('generation-status');
  if (!note) return;
  const existing = note.querySelector('[data-video-links]');
  if (existing) {
    existing.remove();
  }
  if (!videoUrl) return;
  const container = document.createElement('span');
  container.dataset.videoLinks = 'true';
  container.className = 'inline-flex items-center gap-3 ml-3';
  const viewLink = document.createElement('a');
  viewLink.href = videoUrl;
  viewLink.target = '_blank';
  viewLink.rel = 'noopener';
  viewLink.className = 'text-teal-300 underline';
  viewLink.textContent = 'View video';
  const downloadLink = document.createElement('a');
  downloadLink.href = videoUrl;
  downloadLink.download = '';
  downloadLink.rel = 'noopener';
  downloadLink.className = 'text-teal-300 underline';
  downloadLink.textContent = 'Download';
  container.appendChild(viewLink);
  container.appendChild(downloadLink);
  note.appendChild(container);
}

async function loadJobs() {
  const body = document.getElementById('jobs-body');
  if (!body) {
    return [];
  }

  let jobs = [];
  try {
    const res = await fetch(`/list_jobs/${USER_ID}`, { cache: 'no-store' });
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    const payload = await res.json();
    if (!Array.isArray(payload)) {
      throw new Error('Unexpected jobs payload');
    }
    jobs = payload;
  } catch (err) {
    const message = `Failed to load jobs: ${normalizeError(err)}`;
    body.innerHTML = `<tr><td class="px-2 py-2 text-sm text-red-300" colspan="8">${escapeHtml(message)}</td></tr>`;
    clearWebhookDisplay(message);
    return [];
  }

  if (!jobs.length) {
    body.innerHTML = '<tr><td class="px-2 py-2 text-slate-400" colspan="8">No jobs yet.</td></tr>';
    if (activeJobId == null) {
      clearWebhookDisplay('No jobs found yet.');
    }
    return jobs;
  }

  body.innerHTML = '';
  jobs.forEach(job => {
    const tr = document.createElement('tr');
    const videoUrl = extractVideoUrlFromJob(job);
    let videoLinks = '—';
    if (typeof videoUrl === 'string' && videoUrl) {
      const escapedUrl = escapeHtml(videoUrl);
      videoLinks = `<a href="${escapedUrl}" target="_blank" rel="noopener" class="text-teal-400 underline">View</a>`+
                   ` <a href="${escapedUrl}" download class="text-teal-400 underline ml-2">Download</a>`;
    }
    const provider = escapeHtml(job.provider || '—');
    const requestId = escapeHtml(job.external_job_id || '—');
    const promptText = escapeHtml(job.prompt || '');
    const submittedAt = escapeHtml(job.submitted_at || '—');
    const statusText = escapeHtml(job.status || '—');
    const jobIdCell = job.id != null ? escapeHtml(String(job.id)) : '—';
    const { short: errorShort, full: errorFull } = formatJobErrorDetail(job.error);
    const errorCell = errorFull
      ? `<span title="${escapeHtml(errorFull)}">${escapeHtml(errorShort)}</span>`
      : '—';
    tr.innerHTML = `<td class="px-2 py-1">${jobIdCell}</td>`+
                   `<td class="px-2 py-1">${promptText}</td>`+
                   `<td class="px-2 py-1">${provider}</td>`+
                   `<td class="px-2 py-1">${requestId}</td>`+
                   `<td class="px-2 py-1">${statusText}</td>`+
                   `<td class="px-2 py-1">${errorCell}</td>`+
                   `<td class="px-2 py-1">${submittedAt}</td>`+
                   `<td class="px-2 py-1">${videoLinks}</td>`;
    body.appendChild(tr);
  });

  const targetJob =
    activeJobId != null ? jobs.find(job => job.id === activeJobId) : jobs[0];
  if (targetJob) {
    renderWebhookEvent(targetJob);
  } else {
    clearWebhookDisplay('No webhook updates yet.');
  }

  return jobs;
}

async function loadVideos() {
  if (!videosBody) {
    return [];
  }

  let videos = [];
  try {
    const res = await fetch(`/get_videos/${USER_ID}`, { cache: 'no-store' });
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    const payload = await res.json();
    if (!Array.isArray(payload)) {
      throw new Error('Unexpected videos payload');
    }
    videos = payload;
  } catch (err) {
    const message = `Failed to load videos: ${normalizeError(err)}`;
    videosBody.innerHTML = `<tr><td class="px-2 py-2 text-sm text-red-300" colspan="5">${escapeHtml(message)}</td></tr>`;
    return [];
  }

  if (!videos.length) {
    videosBody.innerHTML = '<tr><td class="px-2 py-2 text-slate-400" colspan="5">No videos yet.</td></tr>';
    return videos;
  }

  videosBody.innerHTML = '';
  videos.forEach(video => {
    const tr = document.createElement('tr');
    const idCell = video.id != null ? escapeHtml(String(video.id)) : '—';
    const titleCell = escapeHtml(video.title || 'Video');
    const jobId = video.job_id != null ? escapeHtml(String(video.job_id)) : '—';
    const createdAt = escapeHtml(video.created_at || '—');
    const sourceUrl = typeof video.source_url === 'string' ? video.source_url : '';
    let sourceLinks = '—';
    if (sourceUrl) {
      const safeUrl = escapeHtml(sourceUrl);
      sourceLinks = `<a href="${safeUrl}" target="_blank" rel="noopener" class="text-teal-400 underline">View</a>`+
                    ` <a href="${safeUrl}" download class="text-teal-400 underline ml-2">Download</a>`;
    }
    tr.innerHTML = `<td class="px-2 py-1">${idCell}</td>`+
                   `<td class="px-2 py-1">${titleCell}</td>`+
                   `<td class="px-2 py-1">${sourceLinks}</td>`+
                   `<td class="px-2 py-1">${jobId}</td>`+
                   `<td class="px-2 py-1">${createdAt}</td>`;
    videosBody.appendChild(tr);
  });

  return videos;
}

async function pollJobUntilComplete(jobId, options = {}) {
  const { interval = 5000, maxAttempts = null, requestId = null } = options;
  const sequence = ++pollSequence;
  let lastStatus = null;
  let knownRequestId = requestId;
  activeJobId = jobId;

  for (let attempt = 0; maxAttempts == null || attempt < maxAttempts; attempt += 1) {
    if (sequence !== pollSequence) {
      return;
    }
    if (attempt > 0) {
      await sleep(interval);
    }
    if (sequence !== pollSequence) {
      return;
    }

    let res;
    try {
      res = await fetch(`/job/${jobId}`, {
        cache: 'no-store',
        headers: { Accept: 'application/json' }
      });
    } catch (err) {
      console.error('Failed to poll job status', err);
      continue;
    }

    if (res.status === 404) {
      setStatus('webhook', 'active', 'Waiting for Supabase record');
      updateGenerationStatus(`Waiting for job #${jobId} to appear in Supabase…`, 'active');
      clearWebhookDisplay(`Waiting for job #${jobId} to appear in Supabase…`);
      continue;
    }

    if (!res.ok) {
      console.warn('Job status request failed', res.status, res.statusText);
      continue;
    }

    let job;
    try {
      job = await res.json();
    } catch (err) {
      console.error('Failed to parse job payload', err);
      continue;
    }

    if (!job || typeof job !== 'object') {
      console.warn('Unexpected job payload', job);
      continue;
    }

    renderWebhookEvent(job);

    if (job.status !== lastStatus) {
      lastStatus = job.status;
      loadJobs();
    }

    if (job.external_job_id && job.external_job_id !== knownRequestId) {
      knownRequestId = job.external_job_id;
      setStatus('fal_request', 'done', `Request ${knownRequestId} accepted`);
    }

    const normalizedStatus = typeof job.status === 'string' ? job.status.toLowerCase() : '';

    if (normalizedStatus === 'succeeded') {
      if (sequence !== pollSequence) return;
      setStatus('webhook', 'done', 'fal.ai delivered the result');
      setStatus('generation', 'done', 'Video ready');
      const reqDisplay = knownRequestId ? ` (request ${knownRequestId})` : '';
      updateGenerationStatus(`Video generated successfully for job #${jobId}${reqDisplay}.`, 'success');
      const videoUrl = extractVideoUrlFromJob(job);
      if (videoUrl) {
        showGenerationVideoLinks(videoUrl);
      }
      renderWebhookEvent(job);
      loadJobs();
      loadVideos();
      return;
    }

    if (normalizedStatus === 'failed') {
      if (sequence !== pollSequence) return;
      const { short: errorShort, full: errorFull } = formatJobErrorDetail(job.error);
      const webhookMessage = errorShort ? `fal.ai failure: ${errorShort}` : 'fal.ai reported a failure';
      setStatus('webhook', 'error', webhookMessage);
      setStatus('generation', 'error', 'Generation failed');
      const reqDisplay = knownRequestId ? ` (request ${knownRequestId})` : '';
      let statusNote = `Video generation failed for job #${jobId}${reqDisplay}.`;
      if (errorFull) {
        statusNote += ` Reason: ${errorFull}`;
      }
      const debugMessage = errorFull ? `fal.ai error: ${errorFull}` : 'fal.ai reported a failure.';
      updateDebugMessage(debugMessage, 'error');
      console.error('fal.ai job failed', {
        jobId,
        requestId: knownRequestId || job.external_job_id || null,
        error: errorFull || job.error || null
      });
      updateGenerationStatus(statusNote, 'error');
      renderWebhookEvent(job);
      loadJobs();
      return;
    }

    if (normalizedStatus === 'running') {
      setStatus('webhook', 'active', 'fal.ai processing');
      setStatus('generation', 'active', 'Video generation in progress');
      const reqDisplay = knownRequestId ? ` (request ${knownRequestId})` : '';
      updateGenerationStatus(`Video generation in progress${reqDisplay}…`, 'active');
    } else if (normalizedStatus === 'queued') {
      setStatus('webhook', 'active', 'Waiting for fal.ai to start');
      setStatus('generation', 'pending', 'Waiting to start');
      const reqDisplay = knownRequestId ? ` (request ${knownRequestId})` : '';
      updateGenerationStatus(`Job queued for generation${reqDisplay}…`, 'active');
    } else {
      setStatus('webhook', 'active', job.status || 'In progress');
      setStatus('generation', 'active', 'Processing update received');
      updateGenerationStatus(`Current job status: ${job.status}`, 'active');
    }
  }

  if (sequence !== pollSequence) {
    return;
  }
  if (maxAttempts != null) {
    setStatus('webhook', 'error', 'Timed out waiting for webhook');
    setStatus('generation', 'error', 'Timed out');
    updateGenerationStatus('Timed out waiting for video generation to finish.', 'error');
    clearWebhookDisplay(`Timed out waiting for webhook updates for job #${jobId}.`);
  }
}

document.getElementById('job-form').addEventListener('submit', async (e) => {
  e.preventDefault();
  const prompt = document.getElementById('prompt').value;
  const imageUrl = document.getElementById('image-url').value;
  resetStatuses();
  setStatus('queued', 'active', 'Submitting job');
  setStatus('fal_request', 'active', 'Sending request to fal.ai');
  setStatus('webhook', 'pending', 'Waiting for webhook');
  updateDebugMessage('Submitting job to fal.ai...');
  clearWebhookDisplay('Submitting job to fal.ai…');
  let jobData;
  let jobId = null;
  let externalJobId = null;
  let webhookUrl = null;
  try {
    const jobRes = await fetch('/submit_job_fal', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        user_id: USER_ID,
        prompt,
        text_input: prompt,
        image_url: imageUrl
      })
    });

    let payload;
    try {
      payload = await jobRes.json();
    } catch (_) {
      setStatus('queued', 'error', 'Invalid server response');
      setStatus('fal_request', 'error', 'fal.ai submission failed');
      setStatus('webhook', 'error', 'Webhook not scheduled');
      throw new Error('Failed to parse response from server');
    }

    if (jobRes.ok) {
      jobData = payload;
      jobId = jobData.job_id ?? jobData.id ?? null;
      externalJobId = jobData.external_job_id || jobData.request_id || null;
      webhookUrl = jobData.webhook_url || null;
      if (jobId != null) {
        activeJobId = jobId;
      }
      setStatus('queued', 'done', jobId ? `Job #${jobId} queued` : 'Job queued');
      const requestMessage = externalJobId ? `Request ${externalJobId} queued` : 'Request queued';
      setStatus('fal_request', 'done', requestMessage);
      setStatus('webhook', 'active', 'Awaiting fal.ai webhook');
      const details = [
        jobId ? `Job #${jobId} queued on fal.ai.` : 'Job queued on fal.ai.',
        externalJobId ? `Request ID: ${externalJobId}` : null,
        webhookUrl ? `Webhook: ${webhookUrl}` : null
      ].filter(Boolean).join(' ');
      updateDebugMessage(details || 'Job queued.', 'success');
      const waitingMessage = jobId
        ? `Waiting for webhook updates for job #${jobId}…`
        : 'Waiting for webhook updates…';
      clearWebhookDisplay(waitingMessage);
    } else {
      let detail = `${jobRes.status} ${jobRes.statusText}`;
      if (payload && payload.error) {
        detail = payload.error;
      }
      setStatus('queued', 'error', 'Job submission failed');
      setStatus('fal_request', 'error', 'fal.ai submission failed');
      setStatus('webhook', 'error', 'Webhook not scheduled');
      clearWebhookDisplay(`Job submission failed: ${detail}`);
      throw new Error(detail);
    }

    if (e.target && typeof e.target.reset === 'function') {
      e.target.reset();
    }

    loadJobs();
  } catch (err) {
    setStatus('queued', 'error', 'Job submission failed');
    setStatus('fal_request', 'error', 'fal.ai submission failed');
    setStatus('webhook', 'error', 'Webhook not scheduled');
    updateDebugMessage(`Job submission failed: ${normalizeError(err)}`, 'error');
    clearWebhookDisplay(`Job submission failed: ${normalizeError(err)}`);
    return;
  }

  const summaryJobId = jobId ?? jobData?.id;
  setStatus('summary', 'active', 'Fetching Wikipedia data with Ollama');
  const submissionNote = summaryJobId ? `Job #${summaryJobId}` : 'Job';
  const requestNote = externalJobId ? ` (request ${externalJobId})` : '';
  updateDebugMessage(`${submissionNote}${requestNote} submitted. Running Wikipedia scraping debug...`);

  try {
    const summaryRes = await fetch('/wiki_summary', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ query: prompt })
    });

    if (!summaryRes.ok) {
      let detail = `${summaryRes.status} ${summaryRes.statusText}`;
      try {
        const payload = await summaryRes.json();
        if (payload && payload.error) {
          detail = payload.error;
        }
      } catch (_) {}
      setStatus('summary', 'error', 'Summary failed');
      setStatus('generation', 'pending', 'Waiting to start');
      throw new Error(detail);
    }

    const data = await summaryRes.json();
    setStatus('summary', 'done', 'Course script generated');
    renderScrapeResults(data, summaryJobId);
  } catch (err) {
    updateDebugMessage(`Scraping debug failed: ${normalizeError(err)}`, 'error');
    return;
  }

  setStatus('generation', 'active', 'Waiting for generation update');
  setStatus('webhook', 'active', 'Waiting for fal.ai webhook');
  updateGenerationStatus('Awaiting video generation status...', 'active');
  const pollJobId = summaryJobId ?? jobData.id;
  if (pollJobId == null) {
    setStatus('generation', 'error', 'Missing job identifier');
    setStatus('webhook', 'error', 'Missing job identifier');
    updateGenerationStatus('Cannot monitor job without an ID.', 'error');
    clearWebhookDisplay('Cannot monitor job without an ID.');
    return;
  }
  pollJobUntilComplete(pollJobId, { requestId: externalJobId }).catch((err) => {
    setStatus('generation', 'error', 'Status check failed');
    setStatus('webhook', 'error', 'Status check failed');
    updateGenerationStatus(`Failed to check job status: ${normalizeError(err)}`, 'error');
    clearWebhookDisplay(`Failed to check job status: ${normalizeError(err)}`);
  });
});

const refreshButton = document.getElementById('refresh-jobs');
if (refreshButton) {
  refreshButton.addEventListener('click', loadJobs);
}

const refreshVideosButton = document.getElementById('refresh-videos');
if (refreshVideosButton) {
  refreshVideosButton.addEventListener('click', loadVideos);
}

document.addEventListener('DOMContentLoaded', () => {
  initStatusUI();
  loadJobs();
  loadVideos();
});

</script>
{% endblock %}
