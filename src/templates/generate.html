{% extends 'base.html' %}
{% block title %}Generate Video{% endblock %}
{% block content %}
<div class="max-w-2xl mx-auto space-y-6">
  <h1 class="text-3xl font-semibold text-center">Generate Video</h1>
  <p class="text-sm text-slate-400 text-center">
    Submit a prompt to schedule a fal.ai video generation request. The job is queued on
    fal.ai and this page monitors the status by polling your Supabase records.
  </p>
  <form id="gen-form" class="space-y-4">
    <input id="prompt" class="w-full px-4 py-2 rounded bg-slate-900 border border-slate-700 focus:outline-none focus:ring-2 focus:ring-teal-500" type="text" placeholder="Enter prompt" required />
    <input id="image-url" class="w-full px-4 py-2 rounded bg-slate-900 border border-slate-700 focus:outline-none focus:ring-2 focus:ring-teal-500" type="text" placeholder="Image URL" required />
    <button class="w-full py-2 rounded bg-teal-500 hover:bg-teal-400 text-slate-900 font-semibold" type="submit">Generate</button>
    <button id="wiki-btn" class="w-full py-2 rounded bg-indigo-500 hover:bg-indigo-400 text-slate-900 font-semibold" type="button">Wiki Search</button>
  </form>
  <section class="p-4 rounded-lg border border-slate-700 bg-slate-900/50 space-y-2">
    <h2 class="text-sm font-semibold text-slate-200">fal.ai request status</h2>
    <p id="request-state" class="text-xs text-slate-400">No request submitted yet.</p>
    <dl id="request-meta" class="grid grid-cols-1 gap-1 text-xs text-slate-400 hidden">
      <div class="flex items-center justify-between gap-2">
        <dt class="font-medium text-slate-300">Request ID</dt>
        <dd id="request-id" class="text-right break-all"></dd>
      </div>
      <div class="flex items-center justify-between gap-2">
        <dt class="font-medium text-slate-300">Video</dt>
        <dd id="request-video" class="text-right break-all text-teal-300"></dd>
      </div>
    </dl>
    <div id="request-logs-wrapper" class="hidden rounded-md border border-slate-800/80 bg-slate-950/50 p-2 space-y-1">
      <h3 class="text-[11px] font-semibold uppercase tracking-wide text-slate-400">fal.ai activity</h3>
      <ol id="request-logs" class="space-y-1 text-[11px] leading-snug text-slate-300"></ol>
    </div>
  </section>
  <pre id="submission-response" class="bg-slate-900 p-4 rounded text-sm"></pre>
  <pre id="result" class="bg-slate-900 p-4 rounded text-sm"></pre>
  <pre id="wiki-result" class="bg-slate-900 p-4 rounded text-sm"></pre>
</div>
<script>
const USER_ID = {{ user_id | tojson }};
const requestState = document.getElementById('request-state');
const requestMeta = document.getElementById('request-meta');
const requestIdEl = document.getElementById('request-id');
const requestVideoEl = document.getElementById('request-video');
const requestLogsWrapper = document.getElementById('request-logs-wrapper');
const requestLogsList = document.getElementById('request-logs');
const submissionOutput = document.getElementById('submission-response');
const falResultOutput = document.getElementById('result');

let jobPollTimeout = null;
let falStatusTimeout = null;
let activeJobId = null;
let lastLogSignature = '';

function setState(message, tone = 'info') {
  if (!requestState) return;
  const classes = {
    info: 'text-xs text-slate-300',
    active: 'text-xs text-amber-300',
    success: 'text-xs text-emerald-300',
    error: 'text-xs text-red-300'
  };
  requestState.className = classes[tone] || classes.info;
  requestState.textContent = message;
}

function renderJson(target, payload) {
  if (!target) return;
  if (payload === null || payload === undefined) {
    target.textContent = '';
    return;
  }
  try {
    target.textContent = JSON.stringify(payload, null, 2);
  } catch (err) {
    target.textContent = String(payload);
  }
}

function updateVideoLink(url) {
  if (!requestVideoEl) return;
  requestVideoEl.innerHTML = '';
  if (!url) {
    return;
  }
  const link = document.createElement('a');
  link.href = url;
  link.target = '_blank';
  link.rel = 'noopener noreferrer';
  link.className = 'text-teal-300 hover:text-teal-200 underline';
  link.textContent = 'Open video';
  requestVideoEl.appendChild(link);
}

function updateRequestMeta(data) {
  if (!requestMeta) return;
  if (!data) {
    requestMeta.classList.add('hidden');
    if (requestIdEl) requestIdEl.textContent = '';
    updateVideoLink('');
    return;
  }
  requestMeta.classList.remove('hidden');
  if (requestIdEl) {
    const identifier = data.external_job_id || data.request_id || '—';
    requestIdEl.textContent = identifier;
  }
  updateVideoLink(data.video_url || '');
}

function normalizeLogEntry(entry) {
  if (entry === null || entry === undefined) return null;
  if (typeof entry === 'string') {
    const trimmed = entry.trim();
    return trimmed || null;
  }
  if (typeof entry === 'number' || typeof entry === 'boolean') {
    return String(entry);
  }
  if (typeof entry === 'object') {
    for (const key of ['message', 'msg', 'text', 'detail', 'status']) {
      if (typeof entry[key] === 'string' && entry[key].trim()) {
        return entry[key].trim();
      }
    }
    try {
      return JSON.stringify(entry);
    } catch (err) {
      return String(entry);
    }
  }
  return String(entry);
}

function updateRequestLogs(entries) {
  if (!requestLogsWrapper || !requestLogsList) return;
  const values = Array.isArray(entries)
    ? entries
    : entries !== null && entries !== undefined
      ? [entries]
      : [];
  const normalized = values
    .map((entry) => normalizeLogEntry(entry))
    .filter((entry) => typeof entry === 'string' && entry);
  const signature = normalized.join('||');
  if (!normalized.length) {
    requestLogsWrapper.classList.add('hidden');
    requestLogsList.innerHTML = '';
    lastLogSignature = '';
    return;
  }
  if (signature === lastLogSignature) {
    return;
  }
  lastLogSignature = signature;
  requestLogsWrapper.classList.remove('hidden');
  requestLogsList.innerHTML = '';
  normalized.forEach((text, index) => {
    const item = document.createElement('li');
    item.className = 'rounded border border-slate-800/70 bg-slate-950/60 px-2 py-1';
    item.textContent = `${index + 1}. ${text}`;
    requestLogsList.appendChild(item);
  });
}

function stopJobPolling() {
  if (jobPollTimeout) {
    clearTimeout(jobPollTimeout);
    jobPollTimeout = null;
  }
}

function stopFalStatusPolling() {
  if (falStatusTimeout) {
    clearTimeout(falStatusTimeout);
    falStatusTimeout = null;
  }
}

function extractVideoUrl(payload) {
  if (!payload) return null;
  if (typeof payload === 'string') {
    return payload;
  }
  if (typeof payload.video_url === 'string' && payload.video_url) {
    return payload.video_url;
  }
  if (payload.video && typeof payload.video === 'object') {
    const nested = extractVideoUrl(payload.video);
    if (nested) return nested;
  }
  if (Array.isArray(payload.videos)) {
    for (const item of payload.videos) {
      const nested = extractVideoUrl(item);
      if (nested) return nested;
    }
  }
  if (typeof payload.url === 'string' && payload.url) {
    return payload.url;
  }
  return null;
}

async function pollJobStatus(jobId) {
  stopJobPolling();
  if (!jobId) return;

  const poll = async () => {
    if (jobId !== activeJobId) return;
    try {
      const resp = await fetch(`/list_jobs/${USER_ID}`, { cache: 'no-store' });
      if (!resp.ok) {
        throw new Error(`HTTP ${resp.status}`);
      }
      const jobs = await resp.json();
      const job = Array.isArray(jobs) ? jobs.find((item) => item.id === jobId) : null;
      if (!job) {
        setState('Waiting for job to appear in Supabase…', 'active');
      } else {
        updateRequestMeta(job);
        if (job.status === 'succeeded') {
          const url = extractVideoUrl(job);
          if (url) {
            updateVideoLink(url);
            setState('✅ Video generated successfully! Your video is ready.', 'success');
          } else {
            setState('✅ Video generated successfully! Check your library for the file.', 'success');
          }
          stopFalStatusPolling();
          return;
        }
        if (job.status === 'failed') {
          const reason = job.error ? ` Reason: ${job.error}` : '';
          setState(`The request failed.${reason}`, 'error');
          stopFalStatusPolling();
          return;
        }
        const statusLabel = job.status === 'running' ? 'Processing' : 'Queued';
        setState(`${statusLabel}… processing at fal.ai.`, 'active');
      }
    } catch (err) {
      setState(`Unable to fetch job status: ${err.message}`, 'error');
      stopFalStatusPolling();
      return;
    }
    jobPollTimeout = setTimeout(poll, 4000);
  };

  poll();
}

async function pollFalStatus(jobId) {
  stopFalStatusPolling();
  if (!jobId) return;

  const poll = async () => {
    if (jobId !== activeJobId) return;
    try {
      const resp = await fetch(`/fal_status/${jobId}`, { cache: 'no-store' });
      let payload = null;
      try {
        payload = await resp.json();
      } catch (err) {
        payload = null;
      }

      if (resp.status === 404) {
        updateRequestLogs([]);
      } else if (!resp.ok) {
        const message = payload && payload.error ? payload.error : `HTTP ${resp.status}`;
        updateRequestLogs([`fal.ai status error: ${message}`]);
      } else if (payload) {
        if (Array.isArray(payload.logs)) {
          updateRequestLogs(payload.logs);
        } else {
          updateRequestLogs([]);
        }

        if (payload.status && !payload.result) {
          renderJson(falResultOutput, payload.status);
        }

        if (payload.result) {
          renderJson(falResultOutput, payload.result);
          const videoUrl = extractVideoUrl(payload.video || payload.result);
          if (videoUrl) {
            updateVideoLink(videoUrl);
          }
        } else if (payload.video) {
          const videoUrl = extractVideoUrl(payload.video);
          if (videoUrl) {
            updateVideoLink(videoUrl);
          }
        } else if (payload.video_url) {
          updateVideoLink(payload.video_url);
        }

        if (typeof payload.status_upper === 'string') {
          const normalized = payload.status_upper.toUpperCase();
          if (['FAILED', 'ERROR'].includes(normalized)) {
            setState('The fal.ai request failed.', 'error');
            stopFalStatusPolling();
            return;
          }
          if (['SUCCESS', 'SUCCEEDED', 'COMPLETED', 'OK'].includes(normalized)) {
            stopFalStatusPolling();
            return;
          }
        }
      }
    } catch (err) {
      updateRequestLogs([`fal.ai status error: ${err.message}`]);
    }
    if (jobId !== activeJobId) return;
    falStatusTimeout = setTimeout(poll, 5000);
  };

  poll();
}

document.getElementById('gen-form').addEventListener('submit', async (e) => {
  e.preventDefault();
  const prompt = document.getElementById('prompt').value;
  const imageUrl = document.getElementById('image-url').value;

  stopJobPolling();
  stopFalStatusPolling();
  activeJobId = null;
  lastLogSignature = '';
  updateRequestLogs([]);
  updateRequestMeta(null);
  renderJson(submissionOutput, null);
  renderJson(falResultOutput, null);

  setState('Submitting job to fal.ai…', 'active');

  const res = await fetch('/submit_job_fal', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
      user_id: USER_ID,
      prompt,
      text_input: prompt,
      image_url: imageUrl
    })
  });

  let data;
  try {
    data = await res.json();
  } catch (err) {
    setState('Failed to parse response from the server.', 'error');
    return;
  }

  renderJson(submissionOutput, data);

  if (!res.ok) {
    const errorMsg = data && data.error ? data.error : 'The fal.ai submission failed.';
    setState(errorMsg, 'error');
    updateRequestMeta(null);
    return;
  }

  activeJobId = data.job_id;
  updateRequestMeta(data);
  setState('Job queued at fal.ai. Waiting for status updates…', 'active');
  pollJobStatus(activeJobId);
  pollFalStatus(activeJobId);
});

document.getElementById('wiki-btn').addEventListener('click', async () => {
  const prompt = document.getElementById('prompt').value;
  const res = await fetch('/wiki_summary', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({query: prompt})
  });
  const data = await res.json();
  document.getElementById('wiki-result').textContent = JSON.stringify(data, null, 2);
});
</script>
{% endblock %}
